**使用 8086 ASM汇编**

**源程序.asm  通过 编译,链接 生成 二进制机器码文件**

> **ICH HUB 是南桥, IO集中控制器**
>
> **CPU里面存在一块小电池, 用于给 时钟供电**

**所有的存储器  (RAM,ROM都算)  都会被看成是一个逻辑存储器, 进行统一编址,每个存储器都会占有一段地址空间**

**向某个特定的内存位置写入信息和数据, 就可以控制某个硬件和传入给这个硬件信息**

<img src="png/8086内存地址空间的分配方案.png" alt="8086内存地址空间的分配方案" style="zoom:80%;" />

<img src="png/实模式下内存分布.jpg" alt="实模式下内存分布" style="zoom:80%;" />



<img src="png/计算机结构图.png" alt="计算机结构图" style="zoom:67%;" />



## 目录

- [编译过程](#编译过程)
- [运行过程](#运行过程)
- [寄存器和数据存储](#寄存器和数据存储)
- [内存中存储的字型和字节型区分](#内存中存储的字型和字节型区分)
- [时钟](#时钟)
- [确定物理地址的方法](#确定物理地址的方法)
- [代码段操作](#代码段操作)
- [DS和数据段](#DS和数据段)
  - [数据段操作](#数据段操作)
- [栈段指针SS和SP寄存器](#栈段指针SS和SP寄存器)
- [伪指令](#伪指令)
- [实用程序结构](#实用程序结构)
  - [将字符进行大小写转换示例代码](#将字符进行大小写转换示例代码)
- [汇编指令详解](#汇编指令详解)
  - [mov和add](#mov和add)
  - [sub](#sub)
  - [inc](#inc)
  - [loop](#loop)
  - [and和or](#and和or)
  - 



## 编译过程

**可执行文件 头部有相关描述信息, 其他的没有**

**Dos 使用的 masm 编译器,  源代码中使用的是标志号 十六进制数,  16H ,10D**

**Linux和Mac 使用的是 nasm 编译器, 源代码中使用的是  0x 表示的十六进制数**

**开始执行后, CX 寄存器里面保存的是 代码段的长度**

```bash
# a.asm  -> a.obj  ->  a.out/exe
# 源代码  -> 目标文件 ->  可执行文件
# masm/nasm编译源代码生成目标文件  ->  link 将.obj目标文件 转化成可执行文件

# 其他文件:
	  # masm 会生成以下中间文件
		    # *.LST   列表文件; 编译器将源程序编译成目标文件过程中产生的 中间结果.
		    # *.CRF   交叉引用文件;  和列表文件一样, 是编译器将源程序编译为目标文件过程中产生的中间结果
		# link 会生成以下中间文件
				# *.map    映像文件; 是连接程序将目标文件链接为可执行文件过程中产生的中间结果
				# *.lib    库文件; 包含了一些可以调用的子程序, 就是动态库文件
				

```



## 运行过程

- **Dos 启动后, 计算机由 '命令解释器' (程序command.com) 控制**
- **运行可执行程序时,  command 将程序加载入内存, 设置 CPU 的CS:IP 指向程序的第一条指令(即程序的入口), 使得程序得以运行**
- **程序运行结束后, 返回到 '命令解释器', CPU 继续执行 command**
- **运行 DosBox的 debug时:**
  - **command程序加载debug.exe**
  - **debug 将 用户程序 加载到内存**
    - 程序运行结束后, 要返回到debug中,  使用q命令来退出debug 
      - **最后会返回到 command中**





## 寄存器和数据存储

**8086 CPU 拥有14个寄存器**

**每个寄存器都是16位的, 可以放两个字节**

**8086字长为16位, 目前的32位处理器字长为32位,  X86-64 则是64位字长,字长是运算器每次能处理的数据最大长度**

==**保护模式, 实模式 都是以段寄存器为基础的**==



- **`CS:IP  指令地址`**
- **`DS:偏移量  数据地址`**
- **`SS:SP  栈地址`**

|      寄存器编号 | 作用                             | 具体描述                                                     |
| --------------: | -------------------------------- | :----------------------------------------------------------- |
|  **AX**, AH, AL | **通用寄存器, AH高8位, AL低8位** | **整数商寄存器, div BX ;整数商会放在AX , 余数在DX**          |
|  **BX**, BH, BL | 通用寄存器                       | **基址寄存器**                                               |
| **CX** , CH, CL | 通用寄存器                       | **控制  loop循环次数,  程序执行后存放代码长度**              |
|  **DX**, DH, DL | 通用寄存器                       | **余数商寄存器, div BX ;整数商会放在AX , 余数在DX**          |
|   ------------- | -------------                    |                                                              |
|          **SI** | **变址寄存器**                   |                                                              |
|              DI | 变址寄存器                       |                                                              |
|   ------------- | -------------                    |                                                              |
|          **SP** | **指针寄存器**                   | **栈顶偏移地址,  SS:SP**                                     |
|              BP | 指针寄存器                       |                                                              |
|   ------------- | -------------                    |                                                              |
|          **IP** | **指令指针寄存器**               | **指向下一条要执行的指令的地址, CS:IP 才是地址位置**         |
|   ------------- | -------------                    |                                                              |
|          **CS** | **代码段寄存器**                 | **代码段寄存器, CS:IP 表示下条指令地址, 会被抽象为PC寄存器** |
|              SS | 栈段寄存器   **stack栈**         | **栈段地址寄存器,  SS:SP  表示栈顶位置**                     |
|          **DS** | 数据段寄存器                     | **数据段寄存器,  DS:偏移量   即可得到数据段的地址**          |
|              ES | 附加段寄存器                     | **附加寄存器**                                               |
|   ------------- | -------------                    |                                                              |
|  **PSW / FALG** | **标志寄存器**                   | **程序状态字寄存器**                                         |
|   ------------- | -------------                    |                                                              |
|         **ESP** | **栈帧寄存器**                   |                                                              |
|   ------------- | -------------                    |                                                              |
|                 |                                  |                                                              |



## 内存中存储的字型和字节型区分

- **字 （word）计算机进行数据处理时，一次存取、加工和传送的数据长度称为字**
- **8086CPU 一个字是2字节, x86是4字节(双字) , x86_64 是8字节(四字)**
  - 0 地址 **单元** 中存放的 **字节型** 数据是 0x20,  一个字节
  - 0地 **字单元** 中存放的是 **字型** 数据是 0x4E20 , 两个字节, 小端





## 时钟

- **CPU 里面存在两个时钟**
  - 计时器,  由 CPU 内部的一小块电池供电
  - 间隔时钟,  每过一段时间就发出一个中断, 用于控制CPU进程的调度







## 确定物理地址的方法

**所有内存单元  `( 所有RAM, ROM, 包括显卡和BIOS)` 构成的存储空间是一个   一维的线性空间**

**每一个内存单元在这个空间中都有唯一的地址, 这个唯一的地址称为  物理地址**

**内存并没有分段,  段的划分来自于CPU**

16根地址线 可以寻找的地址为64KB,    `(2^16)/1024= 64KB`

==**`CS代码段寄存器, DS数据段寄存器 , SS栈段寄存器,  ES附加段寄存器`**==

> **8086CPU有20根地址总线, 支持最大1MB内存地址,  0xFFFFF ~ 0x00000**
>
> - 8086使用 两个16位地址 `(段地址,偏移地址)`  合成一个20位的物理地址
>   - **传输给 位址加法器, 来合成一个20位的地址**
>     - **物理地址 =  段地址*16  + 偏移地址**
>       - **`0x12402 = 段地址0x1234 * 16 + 偏移地址0x00C2`**
>       - ==**可以用不同的段地址和偏移地址来表示同一个物理地址**==
> - **假设: 数据在 0x21F69 内存单元中, 段地址是 0x2000 **
>   - **数据存在内存  2000:1F60 单元中. 都是十六进制表示. CS=0x2000, IP=0x1F60**
>   - **数据存在内存的 0x2000段中的  0x1F60 单元中**

<img src="png/地址加法器.png" style="zoom:67%;" />

<img src="png/8086CPU给出物理地址的方法.png" alt="8086CPU给出物理地址的方法" style="zoom:67%;" />





## 代码段操作

**CS:IP 是 CPU将要执行的下一条指令的地址**

**使用 jmp指令 来修改 CS和IP,   mov无法修改IP**

```assembly
jmp  段地址:偏移地址
jmp  2AE3:2      #跳转到 0x2AE32 地址处执行,  同时CS修改为 0x2AE3, IP为0x02
jmp  AX          #将IP修改为 AX,并跳转, 当前段:AX
```



## DS和数据段

**将一组长度为N `(N <= 64KB)`, 地址连续, 起始地址为16的倍数的内存单元作为专门存储数据的内存空间, 从而定义了数据段**

**物理地址 = 段地址DS *16 + 偏移地址**

- **段地址就是  DS寄存器的值,  DS段寄存器可以使用其他的寄存器或内存中存储的值来初始化,不能直接给立即数**
- **偏移地址 随便给, 立即数 和寄存器 以及从内存取值都行 , 只要不大于 0xFFFF 即可**

```assembly
mov  DS, [1]    ; 从内存取值, 写给 DS 数据段寄存器
mov  DS, ax
mov  [1], DS
```



## 数据段操作

**用 DS寄存器加偏移值就可以访问那个位置的数据**

**先修改数据段, 成为自己想要访问的地址的数据段,然后再给出偏移即可**

**8086CPU不支持使用 立即数修改段寄存器,必须通过通用寄存器来进行修改 (IP指针寄存器除外,需用jmp)**

```assembly
;先使用BX来设置 DS数据段寄存器的值
push BX  ;先保存
push DS

mov  BX, 0x1000
mov  DS, BX    ; 设置数据段, 如果不设置, 就会读取当前数据段的值
mov  AL, [0]   ; 读取1个字节的数据, 后面翻译成 [DS:0], 物理地址是 0x10000
mov  AX, [1]   ; 读取2个字节的数据, [DS:1]

mov  [4], AX     # 将AX寄存器中两个字节的内容, 放到 DS:4 数据段指向的位置, 占据 0x10004和0x10005
mov  [2], AL     # 将AX寄存器中两个字节的内容, 放到 DS:4 数据段指向的位置, 占据 0x10002

pop  DS
pop  BX
```









## 栈段指针SS和SP寄存器

**CPU不会检查和限制 SP 的栈越界**

```assembly
; SS:SP 是栈顶地址, 从高地址向低地址递减,  SS栈顶段地址:SP栈顶偏移地址
  ; SS:SP 指向栈顶,有数据时他的指向是最后压入进来的数据低地址位置, 栈为空时, 指向无数据位置
; SS 栈顶段寄存器可以通过 寄存器 和 内存数据 来进行赋值
; SP 偏移值 可以使用很多方法赋值
; 栈以 SP为准, 确定能存储数据的长度,  当 SP=0xFF 时, 那么栈只能存储 256个字节
  ; 当 SP为0 后, 继续使用 push  AL 指令, 那么SP会变成 FF , SS不变, 但栈异常了, 不可以这么做

push  AX  ;首先 SP指针减2(AX寄存器2字节), 然后将AX寄存器的值入栈,从低地址向高地址方向写
            ; 计算方式: (SP) = (SP) -2
                   ;   ((SS)*16 + (SP)) = (AX)  ;前面表示的是地址, 后面是将AX内容写入这个地址
                   
pop   AX  ; 将栈顶的值弹出,赋给AX寄存器,  SP= SP +2 
            ; 计算方式:  (AX) = ((SS)*16 + (SP))
            ;           (SP) = (SP) + 2    ;将SP寄存器的值取出来 +2, 再放到SP里面去
```



# 伪指令

**伪指令没有对应的 机器码 指令, 最终不会被CPU执行**

**伪指令 是由编译器来执行的指令, 编译器根据伪指令来进行相关的编译工作**



```assembly
assume cs:codesg   ;伪指令, 段定义, 假设某个 段寄存器 和程序中的某个用 segment ... ends定义的段
									 ; 相关联,  assume cs:codesg 指的是 CS寄存器与 codesg关联, 将定义的 codesg
									 ; 当作程序代码段使用, 也就是计算当前代码段位置,然后赋值给 CS:IP
assume ds:datasg  ;段名,  segment关键字表示 段从当前开始,设置的是数据段,需要将这个值给予DS段寄存器
datasg segment
	db 'BaSiC'         ;这样来定义数据, 每个字符占1字节, 默认位置是  datasg:0, 从B开始
datasg ends          ;定义结束符
									 
codesg segment    
; 上面两条代码在 nasm 汇编中并不存在, 最下面的两条也不存在,  只能在 Dos中使用
start:
	mov  AX, datasg  ; 段位置
	mov  DS, AX      ;段位置给予DS寄存器, 默认偏移值为0,   DS:0
	mov  ax, 0123H  ; 上下两部分都是伪指令
	mov  ax, codesg   ;可以这么使用

ret:
	; 进程在再退出前, 应该使用下面的两条代码 执行退出指令, 交还CPU控制权
	mov  AX, 4c00H  ; 运行完最后这两条指令,当前进程就会结束, 最后这两条指令结合起到一个作用
	int  21H        ; 作用是: 程序运行结束后, 将CPU的控制权交给使它得以运行的程序 (通常是DOS系统)

codesg ends     ;与上面的 codesg segment 配合, 表示段结束
end   start     ;汇编程序结束标记,让编译器知道 程序在此处结束
```





## 实用程序结构

```assembly
assume cs:code , ds:data, ss:stack
data segment   ;设置数据段的内容和位置, 应该让DS段寄存器等于这个值
	dw 0123H, 0456H, 0abcH, 0defH, 0fedH, 0cbaH, 0987H ;8个双字, 占据 16字节
data ends

stack segment ;设置栈段的内容和位置, 当SS段寄存器 等于这个值
	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   ; 16个 双字,占据 32字节
stack ends

; 代码段是默认初始化的, 不需要设置 ,运行时系统就会自动指定
code segment  ; 设置代码段内容和位置
start:
 ; 初始化 各个段寄存器
	mov  AX, stack    ; 栈段的位置值 给予AX
	mov  SS, AX       ; 将AX的值 赋予 SS段寄存器
	mov  SP, 20H      ; 栈的长度, SP =20,  只存放 32字节的数据,SS:SP 
	mov  AX, data     ; 数据段的位置值 给予AX
	mov  DS, AX       ; 初始化数据段, DS:偏移量.    0 <= 偏移量 < 10H
	
;入栈操作
	mov  BX,0
	mov  CX,8    ;设置循环为8次 , 实际执行为 9次, 第一次执行不算做循环
s: 
  push [BX]    ;将 DS:BX 数据段 内存位置的值入栈, 入栈宽度为2,  SP -= 2
  add  BX, 2   ; BX += 2
  pool s 
  
;出栈操作
	mov  BX, 0
	mov  CX, 8
p:
  pop   [BX]  ; 这种出栈顺序, 会将上面入栈的内容,倒过来读取,  12 34 56 变  56 34 12
  add   BX, 2
  loop  p
	
	; 程序结束 , 交还CPU控制权
	mov  AX, 4c00H  ; 运行完最后这两条指令,当前进程就会结束, 最后这两条指令结合起到一个作用
	int  21H        ; 作用是: 程序运行结束后, 将CPU的控制权交给使它得以运行的程序 (通常是DOS系统)

code ends     ;与上面的 code segment 配合, 表示段结束
end   start     ;汇编程序结束标记,让编译器知道 程序在此处结束
	
```





## 将字符进行大小写转换示例代码

```assembly
assume   cs:codesg, ds:datasg 


datasg segment
	db 'BaSiC'         ;小写转大写 ,大写比小写 小20H
	db 'iNfOrMaTiOn'   ;大写转小写
datasg ends


codesg segment
start:
	mov AX, datasg
	mov DS, AX

	mov CX , 5
	mov BX, 0

big:
	mov  AL, [BX]   ; DS:BL
	and  AL,  11011111b    ;0xDF
	mov  [BX], AL
	inc   BX  ;1  2  3   4 
	loop  big ;4 3  2 1  0

	mov CX, 000BH;  0xA
sum:
	mov AL, [BX]
	or  AL,  100000b ;  0x20
	mov [BX] , AL
	inc  BX
	loop sum


	mov ax,4c00H
	int 21H
	
codesg ends
end start
```





# 汇编指令详解

`[ ]` 表示取地址的值, `idata` 表示一个常量(1,2,3..) 这个并不是汇编语法内容.

## mov和add

**8位的寄存器 AL, 如果 ADD 加的值过大 产生了向第九位的进位, 那么这个进位会被清除, 不会放到 AH中**

```assembly
mov  AX, 18D     #将 18 十进制立即数放入 AX寄存器,  AX = 18
mov  AX, BX	     #  AX = BX
mov  AL, 0x100   #  AL是8位寄存器,加上一个9位数还是等于0,溢出位不会添加到 AH中
mov  AL, [2]     # 读取数据段DS寄存器 加2 偏移值 指向的数据内容,放到AL, 读取一个字节
mov  [4], AX     # 将AX寄存器中的内容, 放到DS寄存器加2偏移值的 数据段指向的位置
mov  [BX+SI], AL  #将AL寄存器的值写入地址  DS:BX+SI, 必须是 BX+SI, 否则该指令错误


add  AX, 8       #加法, 将 AX寄存器的值 加上8 ,再写给 AX,  AX+=8
add  AX, BX			 # AX += BX
add  AL, 0x123   # AL = 0x23,  前面的1 会被扔掉,   AX = AH:AL = 0x0023
add  [0],  AL    # 取 DS:0 内存位置的数据, 与AL寄存器的内容相加, 结果写入 DS:0 内存位置
```



## sub

**减法指令**

```assembly
sub  BX,1       # BX = BX -1    寄存器的值减去1, 再写入 BX寄存器
sub  AX,[1]     # AX = AX - [DS:1]
sub  [2], AX    # [DS:2] = [DS:2] - AX
```



## inc

**自增指令**

```assembly
inc  BX   ; 将 BX寄存器的值 增加1 并写回 BX
          ; 同样无法用于 SS  CS  SP 等 栈寄存器
```



## loop

**计数型循环指令**

**首先会减少 CX寄存器的值, 然后再查看减1后的CX寄存器是否大于0**

```assembly
start:           ; start:  表示的是标号, 好比 goto start;  代码
	mov   CX, 10H  ; 10H = 0x10
	loop  start    ; 好比goto 到 start, 先将 CX寄存器的值 -1, 然后再判断CX是否为 0 然后停止循环
				         ; start 标号就是 IP寄存器所存储的偏移值
				         ; loop [SP:IP]   ;与跳转相当,会将CX寄存器的值-1,大于0时,会修改SP和IP寄存器的值
```



## and和or

**and与,  or或**

```assembly
and   AX, 010101b  ;这里尽量使用二进制,  AX = AX & 0x15
or    BX, 010101b  ; BX =  BX | 0x15
```





