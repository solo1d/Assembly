**使用 8086 ASM汇编**

**源程序.asm  通过 编译,链接 生成 二进制机器码文件**

> **ICH HUB 是南桥, IO集中控制器**
>
> **CPU里面存在一块小电池, 用于给 时钟供电**

**所有的存储器  (RAM,ROM都算)  都会被看成是一个逻辑存储器, 进行统一编址,每个存储器都会占有一段地址空间**

**向某个特定的内存位置写入信息和数据, 就可以控制某个硬件和传入给这个硬件信息**

<img src="png/8086内存地址空间的分配方案.png" alt="8086内存地址空间的分配方案" style="zoom:80%;" />

<img src="png/实模式下内存分布.jpg" alt="实模式下内存分布" style="zoom:80%;" />



<img src="png/计算机结构图.png" alt="计算机结构图" style="zoom:67%;" />



## 目录

- [编译过程](#编译过程)
- [寄存器和数据存储](#寄存器和数据存储)
- [内存中存储的字型和字节型区分](#内存中存储的字型和字节型区分)
- [时钟](#时钟)
- [确定物理地址的方法](#确定物理地址的方法)
- [从内存中指定的位置读取数据和写入数据](#从内存中指定的位置读取数据和写入数据)
- [修改CS和IP代码寄存器寄存器的值](#修改CS和IP代码寄存器寄存器的值)
- [DS和数据段](#DS和数据段)
- [栈段指针SS和SP寄存器](#栈段指针SS和SP寄存器)
- [伪指令](#伪指令)
- [汇编指令详解](#汇编指令详解)
  - [mov和add](#mov和add)
  - 



## 编译过程

**可执行文件 头部有相关描述信息, 其他的没有**

**Dos 使用的 masm 编译器,  源代码中使用的是标志号 十六进制数,  16H ,10D**

**Linux和Mac 使用的是 nasm 编译器, 源代码中使用的是  0x 表示的十六进制数**

```bash
# a.asm  -> a.obj  ->  a.out/exe
# 源代码  -> 目标文件 ->  可执行文件

# 其他文件:
	  # *.LST   列表文件; 编译器将源程序编译成目标文件过程中产生的 中间结果.
	  # *.CRF   交叉引用文件;  和列表文件一样, 是编译器将源程序编译为目标文件过程中产生的中间结果
	  
```





## 寄存器和数据存储

**8086 CPU 拥有14个寄存器**

**每个寄存器都是16位的, 可以放两个字节**

**8086字长为16位, 目前的32位处理器字长为32位,  X86-64 则是64位字长,字长是运算器每次能处理的数据最大长度**

==**保护模式, 实模式 都是以段寄存器为基础的**==



- **`CS:IP  指令地址`**
- **`DS:SP  数据地址`**
- **`SS:SP  栈地址`**

|      寄存器编号 | 作用                             | 具体描述                                                     |
| --------------: | -------------------------------- | :----------------------------------------------------------- |
|  **AX**, AH, AL | **通用寄存器, AH高8位, AL低8位** | **整数商寄存器, div BX ;整数商会放在AX , 余数在DX**          |
|  **BX**, BH, BL | 通用寄存器                       | **基址寄存器**                                               |
| **CX** , CH, CL | 通用寄存器                       | **控制  loop  循环次数**                                     |
|  **DX**, DH, DL | 通用寄存器                       | **余数商寄存器, div BX ;整数商会放在AX , 余数在DX**          |
|   ------------- | -------------                    |                                                              |
|          **SI** | **变址寄存器**                   |                                                              |
|              DI | 变址寄存器                       |                                                              |
|   ------------- | -------------                    |                                                              |
|          **SP** | **指针寄存器**                   | **栈顶偏移地址,  SS:SP**                                     |
|              BP | 指针寄存器                       |                                                              |
|   ------------- | -------------                    |                                                              |
|          **IP** | **指令指针寄存器**               | **指向下一条要执行的指令的地址, CS:IP 才是地址位置**         |
|   ------------- | -------------                    |                                                              |
|          **CS** | **代码段寄存器**                 | **代码段寄存器, CS:IP 表示下条指令地址, 会被抽象为PC寄存器** |
|              SS | 栈段寄存器   **stack栈**         | **栈段地址寄存器,  SS:SP  表示栈顶位置**                     |
|          **DS** | 数据段寄存器                     | **数据段寄存器,  DS:偏移量   即可得到数据段的地址**          |
|              ES | 附加段寄存器                     | **附加寄存器**                                               |
|   ------------- | -------------                    |                                                              |
|  **PSW / FALG** | **标志寄存器**                   | **程序状态字寄存器**                                         |
|   ------------- | -------------                    |                                                              |
|         **ESP** | **栈帧寄存器**                   |                                                              |
|   ------------- | -------------                    |                                                              |
|                 |                                  |                                                              |



## 内存中存储的字型和字节型区分

- **字 （word）计算机进行数据处理时，一次存取、加工和传送的数据长度称为字**
- **8086CPU 一个字是2字节, x86是4字节(双字) , x86_64 是8字节(四字)**
  - 0 地址 **单元** 中存放的 **字节型** 数据是 0x20,  一个字节
  - 0地 **字单元** 中存放的是 **字型** 数据是 0x4E20 , 两个字节, 小端





## 时钟

- **CPU 里面存在两个时钟**
  - 计时器,  由 CPU 内部的一小块电池供电
  - 间隔时钟,  每过一段时间就发出一个中断, 用于控制CPU进程的调度







## 确定物理地址的方法

**所有内存单元  `( 所有RAM, ROM, 包括显卡和BIOS)` 构成的存储空间是一个   一维的线性空间**

**每一个内存单元在这个空间中都有唯一的地址, 这个唯一的地址称为  物理地址**

**内存并没有分段,  段的划分来自于CPU**

16根地址线 可以寻找的地址为64KB,    `(2^16)/1024= 64KB`

==**`CS代码段寄存器, DS数据段寄存器 , SS栈段寄存器,  ES附加段寄存器`**==

> **8086CPU有20根地址总线, 支持最大1MB内存地址,  0xFFFFF ~ 0x00000**
>
> - 8086使用 两个16位地址 `(段地址,偏移地址)`  合成一个20位的物理地址
>   - **传输给 位址加法器, 来合成一个20位的地址**
>     - **物理地址 =  段地址*16  + 偏移地址**
>       - **`0x12402 = 段地址0x1234 * 16 + 偏移地址0x00C2`**
>       - ==**可以用不同的段地址和偏移地址来表示同一个物理地址**==
> - **假设: 数据在 0x21F69 内存单元中, 段地址是 0x2000 **
>   - **数据存在内存  2000:1F60 单元中. 都是十六进制表示. CS=0x2000, IP=0x1F60**
>   - **数据存在内存的 0x2000段中的  0x1F60 单元中**

<img src="png/地址加法器.png" style="zoom:67%;" />

<img src="png/8086CPU给出物理地址的方法.png" alt="8086CPU给出物理地址的方法" style="zoom:67%;" />





## 从内存中指定的位置读取数据和写入数据

**用 DS寄存器加偏移值就可以访问那个位置的数据**

**先修改数据段, 成为自己想要访问的地址的数据段,然后再给出偏移即可**

**8086CPU不支持使用 立即数修改段寄存器,必须通过通用寄存器来进行修改 (IP指针寄存器除外,需用jmp)**

```assembly
;先使用BX来设置 DS数据段寄存器的值
push BX  ;先保存
push DS

mov  BX, 0x1000
mov  DS, BX    ; 设置数据段, 如果不设置, 就会读取当前数据段的值
mov  AL, [0]   ; 读取1个字节的数据, 后面翻译成 [DS:0], 物理地址是 0x10000
mov  AX, [1]   ; 读取2个字节的数据, [DS:1]

mov  [4], AX     # 将AX寄存器中两个字节的内容, 放到 DS:4 数据段指向的位置, 占据 0x10004和0x10005
mov  [2], AL     # 将AX寄存器中两个字节的内容, 放到 DS:4 数据段指向的位置, 占据 0x10002

pop  DS
pop  BX
```







## 修改CS和IP代码寄存器寄存器的值

**CS:IP 是 CPU将要执行的下一条指令的地址**

**使用 jmp指令 来修改 CS和IP,   mov无法修改IP**

```assembly
jmp  段地址:偏移地址
jmp  2AE3:2      #跳转到 0x2AE32 地址处执行,  同时CS修改为 0x2AE3, IP为0x02
jmp  AX          #将IP修改为 AX,并跳转, 当前段:AX
```





## DS和数据段

**将一组长度为N `(N <= 64KB)`, 地址连续, 起始地址为16的倍数的内存单元作为专门存储数据的内存空间, 从而定义了数据段**

**物理地址 = 段地址DS *16 + 偏移地址**

- **段地址就是  DS寄存器的值,  DS段寄存器可以使用其他的寄存器或内存中存储的值来初始化,不能直接给立即数**
- **偏移地址 随便给, 立即数 和寄存器 以及从内存取值都行 , 只要不大于 0xFFFF 即可**

```assembly
mov  DS, [1]    ; 从内存取值, 写给 DS 数据段寄存器
mov  DS, ax
mov  [1], DS
```





## 栈段指针SS和SP寄存器

**CPU不会检查和限制 SP 的栈越界**

```assembly
; SS:SP 是栈顶地址, 从高地址向低地址递减,  SS栈顶段地址:SP栈顶偏移地址
  ; SS:SP 指向栈顶,有数据时他的指向是最后压入进来的数据低地址位置, 栈为空时, 指向无数据位置
; SS 栈顶段寄存器可以通过 寄存器 和 内存数据 来进行赋值
; SP 偏移值 可以使用很多方法赋值
; 栈以 SP为准, 确定能存储数据的长度,  当 SP=0xFF 时, 那么栈只能存储 256个字节
  ; 当 SP为0 后, 继续使用 push  AL 指令, 那么SP会变成 FF , SS不变, 但栈异常了, 不可以这么做

push  AX  ;首先 SP = SP -2, 然后将AX寄存器的值入栈,从低地址向高地址方向写
pop   AX  ; 将栈顶的值弹出,赋给AX寄存器,  SP= SP +2 
```







# 伪指令

**伪指令没有对应的 机器码 指令, 最终不会被CPU执行**

**伪指令 是由编译器来执行的指令, 编译器根据伪指令来进行相关的编译工作**



```assembly
assume cs:codesg   ;伪指令, 段定义, 假设某个 段寄存器 和程序中的某个用 segment ... ends定义的段
									 ; 相关联,  assume cs:codesg 指的是 CS寄存器与 codesg关联, 将定义的 codesg
									 ; 当作程序代码段使用, 也就是计算当前代码段位置,然后赋值给 CS:IP
codesg segment     ;段名,  segment关键字表示 段从当前开始
; 上面两条代码在 nasm 汇编中并不存在, 最下面的两条也不存在,  只能在 Dos中使用

	mov ax, 0x123  ; 上下两部分都是伪指令
	
	; 进程在再退出前, 应该使用下面的两条代码 执行退出指令, 交还CPU控制权
	mov  AX, 0x4c00  ; 运行完最后这两条指令,当前进程就会结束, 最后这两条指令结合起到一个作用
	int  0x21        ; 作用是: 程序运行结束后, 将CPU的控制权交给使它得以运行的程序 (通常是DOS系统)

codesg ends     ;与上面的 codesg segment 配合, 表示段结束
end             ;汇编程序结束标记,让编译器知道 程序在此处结束
```







# 汇编指令详解

## mov和add

**8位的寄存器 AL, 如果 ADD 加的值过大 产生了向第九位的进位, 那么这个进位会被清除, 不会放到 AH中**

```assembly
mov  AX, 18D     #将 18 十进制立即数放入 AX寄存器,  AX = 18
mov  AX, BX	     #  AX = BX
mov  AL, 0x100   #  AL是8位寄存器,加上一个9位数还是等于0,溢出位不会添加到 AH中
mov  AL, [2]     # 读取数据段DS寄存器 加2 偏移值 指向的数据内容,放到AL, 读取一个字节
mov  [4], AX     # 将AX寄存器中的内容, 放到DS寄存器加2偏移值的 数据段指向的位置
mov  [BX+SI], AL  #将AL寄存器的值写入地址  DS:BX+SI, 必须是 BX+SI, 否则该指令错误


add  AX, 8       #加法, 将 AX寄存器的值 加上8 ,再写给 AX,  AX+=8
add  AX, BX			 # AX += BX
add  AL, 0x123   # AL = 0x23,  前面的1 会被扔掉,   AX = AH:AL = 0x0023
add  [0],  AL    # 取 DS:0 内存位置的数据, 与AL寄存器的内容相加, 结果写入 DS:0 内存位置
```



## sub

**减法指令**

```assembly
sub  BX,1       # BX = BX -1    寄存器的值减去1, 再写入 BX寄存器
sub  AX,[1]     # AX = AX - [DS:1]
sub  [2], AX    # [DS:2] = [DS:2] - AX
```















